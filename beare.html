<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Duck WebApp</title>
  <style>
    :root{
      --bg1:#7dd3fc;
      --bg2:#bae6fd;
      --card:#ffffffcc;
      --text:#0f172a;
      --muted:#475569;
      --shadow: 0 20px 60px rgba(2, 6, 23, .18);
      --radius: 22px;

      --ok:#16a34a;
      --warn:#f59e0b;
      --bad:#ef4444;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      min-height:100vh;
      display:grid;
      place-items:center;
      overflow:hidden;
      background: linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    /* clouds */
    .cloud{
      position:absolute; width:220px; height:70px;
      background:#fff; border-radius:999px; opacity:.85;
      box-shadow: 0 14px 40px rgba(2, 6, 23, .08);
      animation: drift linear infinite;
    }
    .cloud::before, .cloud::after{ content:""; position:absolute; background:#fff; border-radius:999px; }
    .cloud::before{ width:90px; height:90px; left:20px; top:-35px; }
    .cloud::after{ width:120px; height:120px; left:80px; top:-55px; }
    @keyframes drift{ from{ transform: translateX(-320px);} to{ transform: translateX(calc(100vw + 320px)); } }

    .waves{
      position:absolute; left:0; right:0; bottom:-1px;
      height:35vh; pointer-events:none; opacity:.9;
    }

    .card{
      position:relative;
      width:min(700px, 94vw);
      padding:16px;
      border-radius: var(--radius);
      background: var(--card);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.55);
      text-align:center;
    }

    h1{
      margin:6px 0 8px;
      font-size: clamp(22px, 3.2vw, 32px);
      letter-spacing: .2px;
    }
    .sub{
      margin:0 0 10px;
      color: var(--muted);
      font-size: 14px;
    }

    /* tabs */
    .tabs{
      display:flex;
      gap:10px;
      justify-content:center;
      margin: 10px 0 12px;
      flex-wrap:wrap;
    }
    .tab{
      border:none;
      cursor:pointer;
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 900;
      background: rgba(255,255,255,.75);
      color: var(--text);
      border: 1px solid rgba(15, 23, 42, .08);
      box-shadow: 0 10px 24px rgba(2,6,23,.08);
    }
    .tab.active{
      background: rgba(15, 23, 42, .92);
      color:#fff;
      border-color: rgba(15,23,42,0);
    }
    .panel{ display:none; }
    .panel.active{ display:block; }

    /* game area */
    .game-wrap{
      display:grid;
      place-items:center;
      margin: 8px auto 10px;
    }
    canvas{
      width:min(420px, 92vw);
      height:auto;
      border-radius: 18px;
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(15, 23, 42, .10);
      box-shadow: 0 12px 30px rgba(2,6,23,.12);
      touch-action: manipulation;
    }

    .hud{
      width:min(420px, 92vw);
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin: 10px auto 0;
      flex-wrap:wrap;
      align-items:center;
      color: var(--muted);
      font-weight: 900;
      font-size: 13px;
    }

    .btn-row{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    .btn{
      border:none;
      cursor:pointer;
      border-radius: 14px;
      padding: 10px 14px;
      font-weight: 900;
      background: rgba(15, 23, 42, .92);
      color:#fff;
      box-shadow: 0 12px 30px rgba(2,6,23,.18);
    }
    .btn.secondary{
      background: rgba(255,255,255,.85);
      color: var(--text);
      border: 1px solid rgba(15, 23, 42, .10);
    }

    /* forms */
    .form{
      width:min(520px, 92vw);
      margin: 10px auto 0;
      text-align:left;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(15, 23, 42, .08);
      border-radius: 18px;
      padding: 12px;
      box-shadow: 0 10px 24px rgba(2,6,23,.08);
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:flex-end;
      margin-bottom: 10px;
    }
    label{
      font-weight: 900;
      font-size: 13px;
      color: var(--muted);
      display:block;
      margin-bottom: 6px;
    }
    input{
      width:100%;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(15,23,42,.12);
      outline:none;
      font-weight: 900;
      background: rgba(255,255,255,.9);
    }
    .col{ flex: 1 1 200px; min-width: 200px; }
    .msg{
      margin-top: 6px;
      font-weight: 900;
      font-size: 13px;
      color: var(--muted);
    }
    .msg.good{ color: var(--ok); }
    .msg.bad{ color: var(--bad); }

    /* tiny footer hint */
    .hint{
      margin-top:10px;
      font-size: 13px;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="cloud" style="top:8vh; left:-260px; animation-duration: 42s;"></div>
  <div class="cloud" style="top:16vh; left:-360px; animation-duration: 55s; transform: scale(.9); opacity:.75;"></div>
  <div class="cloud" style="top:26vh; left:-420px; animation-duration: 48s; transform: scale(1.1); opacity:.8;"></div>

  <div class="card">
    <h1>Duck WebApp ü¶Ü</h1>
    <div class="sub">–ò–≥—Ä–∞ –≤ —Å—Ç–∏–ª–µ Flappy + –ø–µ—Ä–µ–≤–æ–¥ –æ—á–∫–æ–≤ –≤ —Ä—É–±–ª–∏</div>

    <div class="tabs">
      <button class="tab active" id="tabGame">–ò–≥—Ä–∞</button>
      <button class="tab" id="tabRub">–ü–µ—Ä–µ–≤–æ–¥ –≤ —Ä—É–±–ª–∏</button>
      <button class="tab" id="tabPromo">–ü—Ä–æ–º–æ–∫–æ–¥</button>
    </div>

    <!-- GAME -->
    <div class="panel active" id="panelGame">
      <div class="game-wrap">
        <canvas id="cv" width="360" height="512" aria-label="Flappy Duck"></canvas>
      </div>

      <div class="hud">
        <div>–û—á–∫–∏: <span id="score">0</span></div>
        <div>–õ—É—á—à–µ–µ: <span id="best">0</span></div>
        <div>–í—Å–µ–≥–æ –æ—á–∫–æ–≤: <span id="total">0</span></div>
      </div>

      <div class="btn-row">
        <button class="btn" id="restartBtn">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
        <button class="btn secondary" id="resetTotalBtn">–°–±—Ä–æ—Å–∏—Ç—å ‚Äú–≤—Å–µ–≥–æ‚Äù</button>
      </div>

      <div class="hint">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –∫–ª–∏–∫ / —Ç–∞–ø / –ø—Ä–æ–±–µ–ª. –¶–µ–ª—å ‚Äî –ø—Ä–æ–ª–µ—Ç–∞—Ç—å –º–µ–∂–¥—É —Ç—Ä—É–±–∞–º–∏.</div>
    </div>

    <!-- RUB -->
    <div class="panel" id="panelRub">
      <div class="form">
        <div class="row">
          <div class="col">
            <label>–ú–æ–∏ –æ—á–∫–∏ (–∏–∑ –∏–≥—Ä—ã)</label>
            <input id="rubPoints" type="number" min="0" step="1" readonly />
          </div>
          <div class="col">
            <label>–¶–µ–Ω–∞ –∑–∞ 1 –æ—á–∫–æ (‚ÇΩ)</label>
            <input id="rate" type="number" min="0" step="0.01" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä 0.50" />
          </div>
        </div>

        <div class="row">
          <button class="btn" id="calcBtn">–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤ —Ä—É–±–ª–∏</button>
          <button class="btn secondary" id="refreshPointsBtn">–û–±–Ω–æ–≤–∏—Ç—å –º–æ–∏ –æ—á–∫–∏</button>
        </div>

        <div class="msg good" id="rubOut">–ù–∞–∂–º–∏ ¬´–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤ —Ä—É–±–ª–∏¬ª ‚Äî –ø–æ–ª—É—á–∏—à—å —Å—É–º–º—É.</div>
      </div>
      <div class="hint">–≠—Ç–æ –ø–µ—Ä–µ–≤–æ–¥ <b>–æ—á–∫–æ–≤ ‚Üí —Ä—É–±–ª–∏</b>.</div>
    </div>

    <!-- PROMO -->
    <div class="panel" id="panelPromo">
      <div class="form">
        <div class="row">
          <div class="col">
            <label>–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥</label>
            <input id="promo" autocomplete="off" />
          </div>
          <button class="btn" id="promoBtn">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>
        <div class="msg" id="promoMsg"> </div>
      </div>
      <div class="hint">–ü—Ä–æ–º–æ–∫–æ–¥ –¥–∞—ë—Ç –±–æ–Ω—É—Å (–º–æ–∂–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ —Ä–∞–∑).</div>
    </div>
  </div>

  <svg class="waves" viewBox="0 0 1440 320" preserveAspectRatio="none" aria-hidden="true">
    <path fill="rgba(255,255,255,.55)" d="M0,192L80,165.3C160,139,320,85,480,90.7C640,96,800,160,960,181.3C1120,203,1280,181,1360,170.7L1440,160L1440,320L1360,320C1280,320,1120,320,960,320C800,320,640,320,480,320C320,320,160,320,80,320L0,320Z"></path>
    <path fill="rgba(255,255,255,.35)" d="M0,256L96,234.7C192,213,384,171,576,170.7C768,171,960,213,1152,218.7C1344,224,1536,192,1632,176L1728,160L1728,320L1632,320C1536,320,1344,320,1152,320C960,320,768,320,576,320C384,320,192,320,96,320L0,320Z"></path>
  </svg>

  <script>
    // ---------- STORAGE ----------
    const K_BEST = 'fd_best';
    const K_TOTAL = 'fd_total';
    const K_RATE = 'fd_rate';
    const K_PROMO_USES = 'fd_promo_uses'; // 0..2

    // –ü—Ä–æ–º–æ–∫–æ–¥: –ù–ï –ü–ò–®–ï–ú –µ–≥–æ –≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ.
    // –û–Ω —É —Ç–µ–±—è –≤ –≥–æ–ª–æ–≤–µ :)
    const SECRET_CODE = '—Ç–µ—Å—Ç';
    const PROMO_MAX_USES = 2;
    const PROMO_BONUS_POINTS = 200; // –±–æ–Ω—É—Å –∫ "–≤—Å–µ–≥–æ –æ—á–∫–æ–≤"

    // ---------- TABS ----------
    const tabGame = document.getElementById('tabGame');
    const tabRub = document.getElementById('tabRub');
    const tabPromo = document.getElementById('tabPromo');
    const panelGame = document.getElementById('panelGame');
    const panelRub = document.getElementById('panelRub');
    const panelPromo = document.getElementById('panelPromo');

    function setTab(name){
      const isGame = name==='game';
      const isRub = name==='rub';
      const isPromo = name==='promo';
      tabGame.classList.toggle('active', isGame);
      tabRub.classList.toggle('active', isRub);
      tabPromo.classList.toggle('active', isPromo);

      panelGame.classList.toggle('active', isGame);
      panelRub.classList.toggle('active', isRub);
      panelPromo.classList.toggle('active', isPromo);

      if (isRub) syncRubPoints();
    }

    tabGame.addEventListener('click', ()=>setTab('game'));
    tabRub.addEventListener('click', ()=>setTab('rub'));
    tabPromo.addEventListener('click', ()=>setTab('promo'));

    // ---------- HUD ----------
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const totalEl = document.getElementById('total');

    let best = Number(localStorage.getItem(K_BEST) || 0);
    let total = Number(localStorage.getItem(K_TOTAL) || 0);
    bestEl.textContent = best;
    totalEl.textContent = total;

    function saveMeta(){
      localStorage.setItem(K_BEST, String(best));
      localStorage.setItem(K_TOTAL, String(total));
      bestEl.textContent = best;
      totalEl.textContent = total;
    }

    // ---------- FLAPPY DUCK ----------
    const cv = document.getElementById('cv');
    const ctx = cv.getContext('2d');

    // duck image (—Ç–≤–æ–π imgur –º–æ–∂–Ω–æ –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –∫ —Ñ–∞–π–ª—É,
    // –Ω–æ —Å–µ–π—á–∞—Å –¥–µ–ª–∞–µ–º "—Ä–∏—Å–æ–≤–∞–Ω–Ω—É—é" —É—Ç–∫—É —á–µ—Ä–µ–∑ canvas, —á—Ç–æ–±—ã –≤—Å–µ–≥–¥–∞ —Ä–∞–±–æ—Ç–∞–ª–æ)
    function drawDuck(x,y,rot){
      ctx.save();
      ctx.translate(x,y);
      ctx.rotate(rot);

      // body
      ctx.beginPath();
      ctx.ellipse(0,0,18,14,0,0,Math.PI*2);
      ctx.fillStyle = '#fbbf24';
      ctx.fill();
      // belly
      ctx.beginPath();
      ctx.ellipse(-2,3,10,8,0,0,Math.PI*2);
      ctx.fillStyle = '#fde68a';
      ctx.fill();

      // head
      ctx.beginPath();
      ctx.ellipse(14,-8,10,9,0,0,Math.PI*2);
      ctx.fillStyle = '#fbbf24';
      ctx.fill();

      // beak
      ctx.beginPath();
      ctx.ellipse(26,-6,8,4,0,0,Math.PI*2);
      ctx.fillStyle = '#fb923c';
      ctx.fill();

      // eye
      ctx.beginPath();
      ctx.arc(16,-10,2.2,0,Math.PI*2);
      ctx.fillStyle = '#0f172a';
      ctx.fill();

      ctx.restore();
    }

    const W = cv.width, H = cv.height;

    let state = 'ready'; // ready, play, over
    let score = 0;

    const duck = {
      x: 90,
      y: H/2,
      vy: 0,
      r: 16
    };

    const GRAV = 0.45;
    const FLAP = -7.3;

    const pipes = [];
    const PIPE_W = 64;
    const GAP = 150;
    let spawnTimer = 0;

    function resetGame(){
      state = 'ready';
      score = 0;
      scoreEl.textContent = score;
      duck.x = 90;
      duck.y = H/2;
      duck.vy = 0;
      pipes.length = 0;
      spawnTimer = 0;
      draw(); // show ready screen
    }

    function addPipe(){
      const minTop = 70;
      const maxTop = H - 140 - GAP;
      const topH = Math.floor(minTop + Math.random()*(maxTop - minTop));
      pipes.push({
        x: W + 20,
        topH,
        passed: false
      });
    }

    function flap(){
      if (state === 'ready'){
        state = 'play';
        duck.vy = FLAP;
        return;
      }
      if (state === 'over'){
        resetGame();
        return;
      }
      if (state === 'play'){
        duck.vy = FLAP;
      }
    }

    function hitPipe(p){
      // duck bbox
      const dx1 = duck.x - duck.r, dx2 = duck.x + duck.r;
      const dy1 = duck.y - duck.r, dy2 = duck.y + duck.r;

      const px1 = p.x, px2 = p.x + PIPE_W;
      const topY2 = p.topH;
      const botY1 = p.topH + GAP;

      const xOverlap = !(dx2 < px1 || dx1 > px2);
      if (!xOverlap) return false;

      // hits top or bottom pipe
      const hitTop = dy1 < topY2;
      const hitBot = dy2 > botY1;
      return hitTop || hitBot;
    }

    function update(){
      // physics
      duck.vy += GRAV;
      duck.y += duck.vy;

      // bounds
      if (duck.y > H - 30){
        duck.y = H - 30;
        gameOver();
      }
      if (duck.y < 10){
        duck.y = 10;
        duck.vy = 0;
      }

      // pipes
      spawnTimer += 1;
      if (spawnTimer > 95){
        spawnTimer = 0;
        addPipe();
      }

      for (let i=0;i<pipes.length;i++){
        const p = pipes[i];
        p.x -= 2.6;

        // score
        if (!p.passed && p.x + PIPE_W < duck.x){
          p.passed = true;
          score += 1;
          scoreEl.textContent = score;
        }

        // collision
        if (hitPipe(p)){
          gameOver();
        }
      }

      // remove offscreen
      while (pipes.length && pipes[0].x + PIPE_W < -20){
        pipes.shift();
      }
    }

    function gameOver(){
      if (state !== 'play') return;
      state = 'over';

      // update best + total
      if (score > best) best = score;
      total += score;
      saveMeta();
    }

    function drawBackground(){
      // sky
      ctx.clearRect(0,0,W,H);
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#93c5fd');
      g.addColorStop(1,'#bae6fd');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      // simple distant hills
      ctx.fillStyle = 'rgba(255,255,255,.55)';
      ctx.beginPath();
      ctx.moveTo(0,H-90);
      ctx.quadraticCurveTo(W*0.25,H-140,W*0.5,H-105);
      ctx.quadraticCurveTo(W*0.75,H-70,W,H-115);
      ctx.lineTo(W,H);
      ctx.lineTo(0,H);
      ctx.closePath();
      ctx.fill();

      // ground
      ctx.fillStyle = 'rgba(15,23,42,.08)';
      ctx.fillRect(0,H-28,W,28);
    }

    function drawPipes(){
      for (const p of pipes){
        // pipes color
        ctx.fillStyle = 'rgba(15,23,42,.18)';
        ctx.strokeStyle = 'rgba(15,23,42,.20)';
        ctx.lineWidth = 2;

        // top pipe
        ctx.fillRect(p.x, 0, PIPE_W, p.topH);
        ctx.strokeRect(p.x, 0, PIPE_W, p.topH);

        // bottom pipe
        const by = p.topH + GAP;
        ctx.fillRect(p.x, by, PIPE_W, H - by - 28);
        ctx.strokeRect(p.x, by, PIPE_W, H - by - 28);
      }
    }

    function drawOverlay(){
      ctx.fillStyle = 'rgba(255,255,255,.75)';
      ctx.strokeStyle = 'rgba(15,23,42,.10)';
      ctx.lineWidth = 2;

      // bubble panel
      const bw = 300, bh = 110;
      const bx = (W-bw)/2, by = 70;
      roundRect(bx,by,bw,bh,18,true,true);

      ctx.fillStyle = '#0f172a';
      ctx.font = '900 18px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(state==='ready' ? '–¢–∞–ø–Ω–∏, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å' : '–ü—Ä–æ–∏–≥—Ä–∞–ª :(', W/2, by+42);

      ctx.fillStyle = '#475569';
      ctx.font = '800 13px system-ui';
      ctx.fillText(state==='ready' ? '–ö–ª–∏–∫ / —Ç–∞–ø / –ø—Ä–æ–±–µ–ª = –≤–∑–º–∞—Ö' : '–ö–ª–∏–∫/—Ç–∞–ø/–ø—Ä–æ–±–µ–ª = –∑–∞–Ω–æ–≤–æ', W/2, by+70);

      if (state==='over'){
        ctx.fillStyle = '#0f172a';
        ctx.font = '900 16px system-ui';
        ctx.fillText(`–û—á–∫–∏: ${score}`, W/2, by+95);
      }
    }

    function roundRect(x,y,w,h,r,fill,stroke){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function draw(){
      drawBackground();
      drawPipes();

      // duck rotation based on velocity
      const rot = Math.max(-0.6, Math.min(0.8, duck.vy * 0.06));
      drawDuck(duck.x, duck.y, rot);

      // score in canvas corner
      ctx.fillStyle = 'rgba(15,23,42,.75)';
      ctx.font = '900 22px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(String(score), 14, 34);

      if (state === 'ready' || state === 'over'){
        drawOverlay();
      }
    }

    function loop(){
      if (state === 'play'){
        update();
      }
      draw();
      requestAnimationFrame(loop);
    }

    // controls
    cv.addEventListener('pointerdown', (e)=>{ e.preventDefault(); flap(); }, {passive:false});
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space'){
        e.preventDefault();
        flap();
      }
    }, {passive:false});

    // buttons
    document.getElementById('restartBtn').addEventListener('click', ()=>{
      resetGame();
      state = 'play';
      duck.vy = FLAP;
    });
    document.getElementById('resetTotalBtn').addEventListener('click', ()=>{
      total = 0;
      saveMeta();
    });

    // start loop
    resetGame();
    requestAnimationFrame(loop);

    // ---------- RUB CONVERTER ----------
    const rubPointsInp = document.getElementById('rubPoints');
    const rateInp = document.getElementById('rate');
    const rubOut = document.getElementById('rubOut');

    function syncRubPoints(){
      rubPointsInp.value = String(total);
      const savedRate = localStorage.getItem(K_RATE);
      if (savedRate !== null && rateInp.value === '') rateInp.value = savedRate;
    }
    document.getElementById('refreshPointsBtn').addEventListener('click', syncRubPoints);

    document.getElementById('calcBtn').addEventListener('click', ()=>{
      const rate = Number(rateInp.value);
      if (!Number.isFinite(rate) || rate < 0){
        rubOut.className = 'msg bad';
        rubOut.textContent = '–í–≤–µ–¥–∏ –Ω–æ—Ä–º–∞–ª—å–Ω—É—é —Ü–µ–Ω—É –∑–∞ 1 –æ—á–∫–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä 0.50).';
        return;
      }
      localStorage.setItem(K_RATE, String(rate));
      const rub = total * rate;
      rubOut.className = 'msg good';
      rubOut.textContent = `–°—É–º–º–∞: ${rub.toFixed(2)} ‚ÇΩ`;
    });

    // ---------- PROMO (hidden code) ----------
    const promoInp = document.getElementById('promo');
    const promoMsg = document.getElementById('promoMsg');
    let promoUses = Number(localStorage.getItem(K_PROMO_USES) || 0);
    if (!Number.isFinite(promoUses)) promoUses = 0;

    function setPromo(text, ok){
      promoMsg.className = 'msg ' + (ok ? 'good' : 'bad');
      promoMsg.textContent = text;
      setTimeout(()=>{ promoMsg.className='msg'; }, 2500);
    }

    document.getElementById('promoBtn').addEventListener('click', ()=>{
      const code = (promoInp.value || '').trim().toLowerCase();
      if (!code){
        setPromo('–í–≤–µ–¥–∏ –∫–æ–¥.', false);
        return;
      }
      if (code !== SECRET_CODE){
        setPromo('–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥.', false);
        return;
      }
      if (promoUses >= PROMO_MAX_USES){
        setPromo('–õ–∏–º–∏—Ç –∞–∫—Ç–∏–≤–∞—Ü–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω.', false);
        return;
      }
      promoUses += 1;
      localStorage.setItem(K_PROMO_USES, String(promoUses));

      total += PROMO_BONUS_POINTS;
      saveMeta();
      promoInp.value = '';
      setPromo('–ë–æ–Ω—É—Å –ø–æ–ª—É—á–µ–Ω.', true);
    });

    // init rub panel values
    syncRubPoints();
  </script>
</body>
</html>
